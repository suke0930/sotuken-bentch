以下に添付するマインドマップ画像と、私が書いたコードをもとにして、  
この機能の **実装** と **仕様書（APIドキュメント＋通信フロー図含む）** を作成してください。

- マインドマップ画像：機能のUIおよび処理フローの概略図です。
- 添付コード：既存のフロント／バックエンドの一部で、これをベースに拡張して構いません。
- ドキュメントは以下を満たすこと：
  - Markdown形式
  - エンドポイント、メソッド、レスポンス例、WebSocketイベントなどを網羅
  - 必要に応じて mermaid などでシーケンス図や通信図を追加
  - 実装コードは Node.js（またはTypeScript）で記述
  - 実運用を想定した構成・コメント付き
- 仕様書と実装は別セクションに分けてください。

---

【補足】
- これは実装依頼ではなく、あくまで仕様とひな形の作成が目的です。
- 実際のプロジェクトではこのドキュメントを共有して開発者に作業してもらいます。
添付ファイルは以下のオブジェクトを参照して下さい。
{
  "mainfile": {
    "filepath": "./index.ts",
    "code": "import express from 'express';\r\nimport './lib/types'; // 型定義をグローバルに適用\r\nimport { SESSION_SECRET } from './lib/constants';\r\nimport { DevUserManager } from './lib/dev-user-manager';\r\nimport { MinecraftServerManager } from './lib/minecraft-server-manager';\r\nimport { MiddlewareManager } from './lib/middleware-manager';\r\nimport { ApiRouter, MinecraftServerRouter, SampleApiRouter } from './lib/api-router';\r\n\r\n/**\r\n * アプリケーションのエントリーポイント\r\n */\r\nasync function main(port: number): Promise<void> {\r\n    // 1. 開発用ユーザーデータの初期化\r\n    await DevUserManager.initialize();\r\n    await MinecraftServerManager.initialize();\r\n\r\n    // 2. Expressアプリケーションのインスタンス化\r\n    const app = express();\r\n\r\n    // 3. ミドルウェアのセットアップ\r\n    const middlewareManager = new MiddlewareManager(app);\r\n    middlewareManager.configure();\r\n\r\n    // 4. ルーティングのセットアップ\r\n    const apiRouter = new ApiRouter(app, middlewareManager.authMiddleware);\r\n    apiRouter.configureRoutes();\r\n\r\n    // 4.1. 【雛形】サンプルAPIルーターのセットアップ\r\n    const sampleApiRouter = new SampleApiRouter(middlewareManager.authMiddleware);\r\n    app.use('/api/sample', sampleApiRouter.router); // `/api/sample` プレフィックスでマウント\r\n\r\n    // 4.2. Minecraftサーバー管理APIルーターのセットアップ\r\n    const mcServerRouter = new MinecraftServerRouter(middlewareManager.authMiddleware);\r\n    app.use('/api/servers', mcServerRouter.router);\r\n\r\n    // 5. エラーハンドリングミドルウェアのセットアップ (ルーティングの後)\r\n    middlewareManager.setupErrorHandlers();\r\n\r\n    // 6. サーバーの起動\r\n    app.listen(port, '0.0.0.0', () => {\r\n        console.log(`=== Front Driver Server Started ===`);\r\n        console.log(`Port: ${port}`);\r\n        console.log(`URL: http://127.0.0.1:${port}/`);\r\n        console.log(`Sample API: http://127.0.0.1:${port}/api/sample/public-info`);\r\n        console.log(`Session Secret: ${SESSION_SECRET.substring(0, 10)}...`);\r\n        console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);\r\n        console.log(`=====================================`);\r\n    });\r\n}\r\n\r\n// サーバー起動（ポート12800で開始）\r\nmain(12800).catch((error) => {\r\n    console.error(\"Failed to start server:\", error);\r\n    process.exit(1);\r\n});\r\n"
  },
  "files": [
    {
      "filepath": "./lib/api-router.ts",
      "code": "import express from 'express';\r\nimport path from 'path';\r\nimport { DevUserManager } from './dev-user-manager';\r\nimport { MinecraftServerManager } from './minecraft-server-manager';\r\nimport { SESSION_NAME } from './constants';\r\n\r\n/**\r\n * APIエンドポイントのルーティングを管理するクラス\r\n */\r\nexport class ApiRouter {\r\n    constructor(\r\n        private app: express.Express,\r\n        private authMiddleware: express.RequestHandler\r\n    ) { }\r\n\r\n    /**\r\n     * すべてのAPIエンドポイントをセットアップする\r\n     */\r\n    public configureRoutes() {\r\n        // 認証状態に関わらずトップページは表示する\r\n        // 実際の表示内容はフロントエンドのJavaScriptが認証状態を見て決定する\r\n        this.app.get('/', (req, res) => {\r\n            // 以前はここで直接ファイルを返していましたが、\r\n            // express.staticミドルウェアが 'web' ディレクトリを配信するため、\r\n            // このルート定義は実質的に不要になる可能性があります。\r\n            // ただし、明示的にルートパスへの応答を定義しておくことは良い習慣です。\r\n            res.sendFile(path.join(__dirname, '..', 'web', 'index.html'));\r\n        });\r\n\r\n        this.app.post('/user/signup', this.signupHandler);\r\n        this.app.post('/user/login', this.loginHandler);\r\n        this.app.get('/user/auth', this.authHandler);\r\n        this.app.post('/user/logout', this.logoutHandler);\r\n\r\n        this.app.get('/demo', this.authMiddleware, (req, res) => {\r\n            res.sendFile(path.join(__dirname, '..', 'web', 'demo.html'));\r\n        });\r\n\r\n        this.app.get('/api/protected', this.authMiddleware, (req, res) => {\r\n            res.json({\r\n                ok: true,\r\n                message: \"保護されたAPIにアクセスしました\",\r\n                user: {\r\n                    userId: req.userId, // authMiddlewareでセットされたuserIdを使用\r\n                    accessTime: new Date().toISOString()\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private signupHandler: express.RequestHandler = async (req, res) => {\r\n        const { id, password } = req.body;\r\n        if (!id || !password || typeof id !== 'string' || typeof password !== 'string') {\r\n            return res.status(400).json({ ok: false, message: \"IDとパスワードが必要です\" });\r\n        }\r\n\r\n        try {\r\n            const userExists = await DevUserManager.hasUser();\r\n            if (userExists) {\r\n                return res.status(409).json({ ok: false, message: \"ユーザーは既に登録されています\" });\r\n            }\r\n\r\n            await DevUserManager.createUser(id, password);\r\n\r\n            // サインアップ後、自動的にログインセッションを開始\r\n            await new Promise<void>((resolve, reject) => {\r\n                req.session.regenerate((err) => {\r\n                    if (err) return reject(err);\r\n                    req.session.userId = id;\r\n                    req.session.loginAt = new Date().toISOString();\r\n                    req.session.save((saveErr) => saveErr ? reject(saveErr) : resolve());\r\n                });\r\n            });\r\n\r\n            return res.status(201).json({ ok: true, message: \"ユーザー登録とログインが完了しました\", userId: id });\r\n        } catch (error) {\r\n            console.error(\"Signup error:\", error);\r\n            return res.status(500).json({ ok: false, message: \"サーバー内部エラーが発生しました\" });\r\n        }\r\n    };\r\n\r\n    private loginHandler: express.RequestHandler = async (req, res) => {\r\n        const { id, password } = req.body;\r\n        if (!id || !password) {\r\n            return res.status(400).json({ ok: false, message: \"IDとパスワードが必要です\" });\r\n        }\r\n\r\n        try {\r\n            const authenticatedUserId = await DevUserManager.authenticate(id, password);\r\n            if (!authenticatedUserId) {\r\n                return res.status(401).json({ ok: false, message: \"IDまたはパスワードが正しくありません\" });\r\n            }\r\n\r\n            await new Promise<void>((resolve, reject) => {\r\n                req.session.regenerate((err) => {\r\n                    if (err) return reject(err);\r\n                    req.session.userId = authenticatedUserId;\r\n                    req.session.loginAt = new Date().toISOString();\r\n                    req.session.save((saveErr) => saveErr ? reject(saveErr) : resolve());\r\n                });\r\n            });\r\n            console.log(`User logged in: ${authenticatedUserId} at ${req.session.loginAt}`);\r\n\r\n            return res.status(200).json({ ok: true, message: \"ログインに成功しました\", userId: authenticatedUserId });\r\n        } catch (error) {\r\n            console.error(\"Login error:\", error);\r\n            return res.status(500).json({ ok: false, message: \"サーバー内部エラーが発生しました\" });\r\n        }\r\n    };\r\n\r\n    private authHandler: express.RequestHandler = (req, res) => {\r\n        if (req.session?.userId) {\r\n            return res.status(200).json({\r\n                ok: true,\r\n                userId: req.session.userId,\r\n                loginAt: req.session.loginAt,\r\n                message: \"認証済みです\"\r\n            });\r\n        }\r\n        // ユーザーがまだ登録されていない状態も考慮\r\n        DevUserManager.hasUser().then(hasUser => {\r\n            console.log(\"Auth check: hasUser =\", hasUser);\r\n            if (!hasUser) {\r\n                return res.status(200).json({ ok: false, reason: \"no_user_registered\", message: \"ユーザーが登録されていません\" });\r\n            }\r\n            return res.status(401).json({ ok: false, reason: \"invalid_session\", message: \"セッションが無効です\" });\r\n        });\r\n    };\r\n\r\n    private logoutHandler: express.RequestHandler = (req, res) => {\r\n        req.session.destroy((err) => {\r\n            if (err) {\r\n                console.error(\"Session destruction failed:\", err);\r\n                return res.status(500).json({ ok: false, reason: \"logout_failed\", message: \"ログアウト処理中にエラーが発生しました\" });\r\n            }\r\n            res.clearCookie(SESSION_NAME);\r\n            return res.status(200).json({ ok: true, message: \"ログアウトしました\" });\r\n        });\r\n    };\r\n}\r\n\r\n/**\r\n * 【雛形】他のAPIエンドポイントを追加する際のサンプルクラス\r\n */\r\nexport class SampleApiRouter {\r\n    public readonly router: express.Router;\r\n\r\n    constructor(private authMiddleware: express.RequestHandler) {\r\n        this.router = express.Router();\r\n        this.configureRoutes();\r\n    }\r\n\r\n    private configureRoutes() {\r\n        this.router.get('/public-info', (req, res) => {\r\n            res.json({ message: 'これは公開情報です。' });\r\n        });\r\n\r\n        this.router.get('/private-data', this.authMiddleware, (req, res) => {\r\n            res.json({\r\n                message: `ようこそ、 ${req.userId} さん。これは保護されたデータです。`,\r\n                timestamp: new Date().toISOString()\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Minecraftサーバー管理APIのルーティングを行うクラス\r\n */\r\nexport class MinecraftServerRouter {\r\n    public readonly router: express.Router;\r\n\r\n    constructor(private authMiddleware: express.RequestHandler) {\r\n        this.router = express.Router();\r\n        this.configureRoutes();\r\n    }\r\n\r\n    private configureRoutes() {\r\n        this.router.get('/', this.authMiddleware, this.getServersHandler);\r\n        this.router.post('/', this.authMiddleware, this.createServerHandler);\r\n        this.router.put('/:id', this.authMiddleware, this.updateServerHandler);\r\n        this.router.delete('/:id', this.authMiddleware, this.deleteServerHandler);\r\n    }\r\n\r\n    private getServersHandler: express.RequestHandler = async (req, res) => {\r\n        const servers = await MinecraftServerManager.getServersForUser(req.userId!);\r\n        res.json({ ok: true, servers });\r\n    };\r\n\r\n    private createServerHandler: express.RequestHandler = async (req, res) => {\r\n        const { serverName, minecraftVersion, serverSoftware, jdkVersion, connectTo, serverFilePath } = req.body;\r\n        if (!serverName || !minecraftVersion || !serverSoftware) {\r\n            return res.status(400).json({ ok: false, message: \"必須項目が不足しています。\" });\r\n        }\r\n        const newServer = await MinecraftServerManager.addServer(\r\n            { serverName, minecraftVersion, serverSoftware, jdkVersion, connectTo, serverFilePath },\r\n            req.userId!\r\n        );\r\n        res.status(201).json({ ok: true, server: newServer });\r\n    };\r\n\r\n    private updateServerHandler: express.RequestHandler = async (req, res) => {\r\n        const { id } = req.params;\r\n        const updates = req.body;\r\n        if (!id) return res.status(400).json({ ok: false, message: \"サーバーIDが必要です。\" });\r\n        const updatedServer = await MinecraftServerManager.updateServer(id, updates, req.userId!);\r\n        if (!updatedServer) return res.status(404).json({ ok: false, message: \"サーバーが見つからないか、更新権限がありません。\" });\r\n        res.json({ ok: true, server: updatedServer });\r\n    };\r\n\r\n    private deleteServerHandler: express.RequestHandler = async (req, res) => {\r\n        const { id } = req.params;\r\n        if (!id) return res.status(400).json({ ok: false, message: \"サーバーIDが必要です。\" });\r\n        const success = await MinecraftServerManager.deleteServer(id, req.userId!);\r\n        if (!success) return res.status(404).json({ ok: false, message: \"サーバーが見つからないか、削除権限がありません。\" });\r\n        res.status(200).json({ ok: true, message: \"サーバーを削除しました。\" });\r\n    };\r\n}\r\n"
    },
    {
      "filepath": "./lib/constants.ts",
      "code": "import path from 'path';\r\nimport crypto from 'crypto';\r\n\r\n// 開発環境用のファイルパス設定\r\nexport const DEV_SECRET_DIR = path.join(__dirname, '..', '..', 'devsecret');\r\nexport const USERS_FILE = path.join(DEV_SECRET_DIR, 'users.json');\r\nexport const SERVERS_FILE = path.join(DEV_SECRET_DIR, 'servers.json');\r\n\r\n// セッション設定\r\nexport const SESSION_SECRET = process.env.SESSION_SECRET || crypto.randomBytes(64).toString('hex');\r\nexport const SESSION_NAME = 'frontdriver-session';"
    },
    {
      "filepath": "./lib/dev-user-manager.ts",
      "code": "import { promises as fs } from 'fs';\r\nimport bcrypt from 'bcrypt';\r\nimport { DEV_SECRET_DIR, USERS_FILE } from './constants';\r\nimport { User } from './types';\r\n\r\nconst SALT_ROUNDS = 10;\r\n\r\n/**\r\n * シングルユーザーの管理クラス\r\n * JSONベースで一人のユーザー情報を管理する\r\n */\r\nexport class DevUserManager {\r\n    /**\r\n     * devsecretディレクトリとデータファイルが存在しない場合に初期化する\r\n     */\r\n    static async initialize() {\r\n        try {\r\n            await fs.mkdir(DEV_SECRET_DIR, { recursive: true });\r\n            await fs.access(USERS_FILE);\r\n        } catch {\r\n            console.log(`Initializing ${USERS_FILE}...`);\r\n            // 初期状態ではユーザーは存在しない (null)\r\n            await fs.writeFile(USERS_FILE, JSON.stringify(null));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 登録されているユーザー情報を取得する\r\n     * @returns ユーザーオブジェクト、存在しない場合はnull\r\n     */\r\n    private static async getUser(): Promise<User | null> {\r\n        try {\r\n            const usersData = await fs.readFile(USERS_FILE, 'utf-8');\r\n            const user = JSON.parse(usersData);\r\n            console.log(\"Read user data:\", user);\r\n            if (!user.id || !user.passwordHash) {\r\n                return null;\r\n            } else {\r\n                return user as User | null;\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error(\"Failed to read user file:\", error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ユーザーが既に登録されているか確認する\r\n     * @returns 登録されていればtrue\r\n     */\r\n    static async hasUser(): Promise<boolean> {\r\n        const user = await this.getUser();\r\n        return user !== null;\r\n    }\r\n\r\n    /**\r\n     * 新しいユーザーを作成する\r\n     * @param id ユーザーID\r\n     * @param password パスワード\r\n     * @returns 作成に成功した場合はtrue\r\n     */\r\n    static async createUser(id: string, password: string): Promise<boolean> {\r\n        if (await this.hasUser()) {\r\n            return false; // 既にユーザーが存在する場合は作成しない\r\n        }\r\n        const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);\r\n        const newUser: User = { id, passwordHash };\r\n        await fs.writeFile(USERS_FILE, JSON.stringify(newUser, null, 2));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * ユーザー認証を行う\r\n     * @param id ユーザーID\r\n     * @param password パスワード\r\n     * @returns 認証成功時はユーザーID、失敗時はnull\r\n     */\r\n    static async authenticate(id: string, password: string): Promise<string | null> {\r\n        const user = await this.getUser();\r\n        if (!user || user.id !== id) return null;\r\n\r\n        const isMatch = await bcrypt.compare(password, user.passwordHash);\r\n        return isMatch ? user.id : null;\r\n    }\r\n}"
    },
    {
      "filepath": "./lib/middleware-manager.ts",
      "code": "import express from 'express';\r\nimport session from 'express-session';\r\nimport path from 'path';\r\nimport { SESSION_NAME, SESSION_SECRET } from './constants';\r\n\r\n/**\r\n * ミドルウェアのセットアップと管理を行うクラス\r\n */\r\nexport class MiddlewareManager {\r\n    constructor(private app: express.Express) { }\r\n\r\n    /**\r\n     * すべてのミドルウェアをセットアップする\r\n     */\r\n    public configure() {\r\n        this.app.use(express.json());\r\n        this.setupSession();\r\n        this.setupStaticFiles();\r\n        this.setupSecurityHeaders();\r\n    }\r\n\r\n    /**\r\n     * エラーハンドリングミドルウェアをセットアップする\r\n     */\r\n    public setupErrorHandlers() {\r\n        this.app.use(this.errorHandler);\r\n    }\r\n\r\n    /**\r\n     * express-sessionミドルウェアをセットアップする\r\n     */\r\n    private setupSession() {\r\n        this.app.use(session({\r\n            name: SESSION_NAME,\r\n            secret: SESSION_SECRET,\r\n            resave: false,\r\n            saveUninitialized: false,\r\n            cookie: {\r\n                secure: false,\r\n                httpOnly: true,\r\n                maxAge: 24 * 60 * 60 * 1000,\r\n                sameSite: 'lax'\r\n            },\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * 静的ファイル配信をセットアップする\r\n     */\r\n    private setupStaticFiles() {\r\n        this.app.use(express.static(path.join(__dirname, '..', 'web')));\r\n    }\r\n\r\n    /**\r\n     * セキュリティ関連のHTTPヘッダーを設定\r\n     */\r\n    private setupSecurityHeaders() {\r\n        this.app.use((req, res, next) => {\r\n            res.setHeader('X-Content-Type-Options', 'nosniff');\r\n            res.setHeader('X-Frame-Options', 'DENY');\r\n            res.setHeader('X-XSS-Protection', '1; mode=block');\r\n            next();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 認証ミドルウェア\r\n     * セッションをチェックし、未認証の場合は401エラーを返す\r\n     */\r\n    public authMiddleware: express.RequestHandler = (req, res, next) => {\r\n        if (req.session?.userId) {\r\n            req.userId = req.session.userId; // 後続の処理で使えるようにリクエストオブジェクトに格納\r\n            return next();\r\n        }\r\n        return res.status(401).json({ ok: false, reason: \"unauthorized\", message: \"ログインが必要です\" });\r\n    };\r\n\r\n    /**\r\n     * グローバルなエラーハンドリングミドルウェア\r\n     */\r\n    private errorHandler: express.ErrorRequestHandler = (error, req, res, next) => {\r\n        console.error('Unhandled error:', error);\r\n        res.status(500).json({ ok: false, reason: \"internal_server_error\", message: \"予期しないエラーが発生しました\" });\r\n    };\r\n}"
    },
    {
      "filepath": "./lib/minecraft-server-manager.ts",
      "code": "import { promises as fs } from 'fs';\r\nimport crypto from 'crypto';\r\nimport { DEV_SECRET_DIR, SERVERS_FILE } from './constants';\r\nimport { MinecraftServerEntry } from './types';\r\n\r\n/**\r\n * 開発用のMinecraftサーバー管理クラス\r\n * JSONベースのサーバーエントリ管理を行う\r\n */\r\nexport class MinecraftServerManager {\r\n    /**\r\n     * devsecretディレクトリとサーバーデータファイルが存在しない場合に初期化する\r\n     */\r\n    static async initialize() {\r\n        try {\r\n            await fs.mkdir(DEV_SECRET_DIR, { recursive: true });\r\n            await fs.access(SERVERS_FILE);\r\n        } catch {\r\n            console.log(`Initializing ${SERVERS_FILE}...`);\r\n            await fs.writeFile(SERVERS_FILE, JSON.stringify([], null, 2));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * サーバーリストをファイルから読み込む\r\n     * @returns サーバーエントリの配列\r\n     */\r\n    private static async readServers(): Promise<MinecraftServerEntry[]> {\r\n        try {\r\n            const serversData = await fs.readFile(SERVERS_FILE, 'utf-8');\r\n            return JSON.parse(serversData);\r\n        } catch (error) {\r\n            console.error(\"Failed to read servers file:\", error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * サーバーリストをファイルに書き込む\r\n     * @param servers サーバーエントリの配列\r\n     */\r\n    private static async writeServers(servers: MinecraftServerEntry[]): Promise<void> {\r\n        await fs.writeFile(SERVERS_FILE, JSON.stringify(servers, null, 2));\r\n    }\r\n\r\n    /**\r\n     * 指定されたユーザーが管理するすべてのサーバーを取得する\r\n     * @param userId ユーザーID\r\n     * @returns ユーザーが管理するサーバーエントリの配列\r\n     */\r\n    static async getServersForUser(userId: string): Promise<MinecraftServerEntry[]> {\r\n        const allServers = await this.readServers();\r\n        return allServers.filter(server => server.managedBy.includes(userId));\r\n    }\r\n\r\n    /**\r\n     * 新しいサーバーを追加する\r\n     * @param serverData 新しいサーバーのデータ\r\n     * @param creatorDevId 作成者のユーザーID\r\n     * @returns 作成されたサーバーエントリ\r\n     */\r\n    static async addServer(\r\n        serverData: Omit<MinecraftServerEntry, 'id' | 'createdAt' | 'isRunning' | 'managedBy'>,\r\n        creatorUserId: string\r\n    ): Promise<MinecraftServerEntry> {\r\n        const allServers = await this.readServers();\r\n        const newServer: MinecraftServerEntry = {\r\n            ...serverData,\r\n            id: crypto.randomUUID(),\r\n            managedBy: [creatorUserId],\r\n            createdAt: new Date().toISOString(),\r\n            isRunning: false,\r\n        };\r\n        allServers.push(newServer);\r\n        await this.writeServers(allServers);\r\n        return newServer;\r\n    }\r\n\r\n    /**\r\n     * サーバー情報を更新する\r\n     * @param id 更新するサーバーのID\r\n     * @param updates 更新内容\r\n     * @param userId 操作を行うユーザーID\r\n     * @returns 更新後のサーバーエントリ、権限がない場合はnull\r\n     */\r\n    static async updateServer(id: string, updates: Partial<Omit<MinecraftServerEntry, 'id'>>, userId: string): Promise<MinecraftServerEntry | null> {\r\n        const allServers = await this.readServers();\r\n        const serverIndex = allServers.findIndex(s => s.id === id);\r\n        if (!allServers[serverIndex]) {\r\n            return null;\r\n        }\r\n        if (serverIndex === -1 || !allServers[serverIndex].managedBy.includes(userId)) {\r\n            return null; // サーバーが存在しないか、権限がない\r\n        }\r\n        const updatedServer = { ...allServers[serverIndex], ...updates, id }; // idは変更不可\r\n        allServers[serverIndex] = updatedServer;\r\n        await this.writeServers(allServers);\r\n        return updatedServer;\r\n    }\r\n\r\n    /**\r\n     * サーバーを削除する\r\n     * @param id 削除するサーバーのID\r\n     * @param userId 操作を行うユーザーID\r\n     * @returns 削除が成功した場合はtrue、失敗した場合はfalse\r\n     */\r\n    static async deleteServer(id: string, userId: string): Promise<boolean> {\r\n        const allServers = await this.readServers();\r\n        const server = allServers.find(s => s.id === id);\r\n        if (!server || !server.managedBy.includes(userId)) return false; // サーバーが存在しないか、権限がない\r\n        const newServers = allServers.filter(s => s.id !== id);\r\n        await this.writeServers(newServers);\r\n        return true;\r\n    }\r\n}\r\n"
    },
    {
      "filepath": "./lib/types.ts",
      "code": "// セッション管理用の型定義\r\ndeclare module 'express-session' {\r\n    interface SessionData {\r\n        userId: string;\r\n        loginAt: string;\r\n    }\r\n}\r\n\r\n// リクエスト型の拡張\r\ndeclare global {\r\n    namespace Express {\r\n        interface Request {\r\n            userId?: string;\r\n        }\r\n    }\r\n}\r\n\r\n// ユーザー情報の型定義\r\nexport interface User {\r\n    id: string;\r\n    passwordHash: string;\r\n}\r\n\r\n// Minecraftサーバーエントリの型定義\r\nexport type ServerSoftware = \"vanilla\" | \"mohist\" | \"paper\" | \"forge\" | \"fabric\" | \"bukkit\" | \"spigot\";\r\n\r\nexport interface MinecraftServerEntry {\r\n    id: string;\r\n    serverName: string;\r\n    minecraftVersion: string;\r\n    serverSoftware: ServerSoftware;\r\n    jdkVersion: string;\r\n    managedBy: string[];\r\n    connectTo: string;\r\n    createdAt: string;\r\n    isRunning: boolean;\r\n    serverFilePath: string;\r\n}"
    },
    {
      "filepath": "./package.json",
      "code": "{\r\n  \"name\": \"front_driver\",\r\n  \"version\": \"0.0.1\",\r\n  \"description\": \"middle ware driver\",\r\n  \"main\": \"dist/index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\r\n    \"build\": \"tsc\",\r\n    \"start\": \"npx ts-node index.ts\",\r\n    \"dev\": \"npx ts-node index.ts\"\r\n  },\r\n  \"keywords\": [\r\n    \"devlop\"\r\n  ],\r\n  \"author\": \"suke\",\r\n  \"license\": \"MIT\",\r\n  \"dependencies\": {\r\n    \"@types/bcrypt\": \"^6.0.0\",\r\n    \"@types/express\": \"^5.0.3\",\r\n    \"@types/express-session\": \"^1.18.2\",\r\n    \"@types/node\": \"^24.5.0\",\r\n    \"@types/uuid\": \"^10.0.0\",\r\n    \"bcrypt\": \"^6.0.0\",\r\n    \"connect-mongo\": \"^5.1.0\",\r\n    \"express\": \"^5.1.0\",\r\n    \"express-session\": \"^1.18.2\",\r\n    \"typescript\": \"^5.9.2\",\r\n    \"uuid\": \"^13.0.0\"\r\n  }\r\n}\r\n"
    }
  ]
}